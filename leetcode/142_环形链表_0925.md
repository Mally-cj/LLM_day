## **题目:** [Linked List Cycle II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

**记录原因**: 要理解这个实现简单的代码，需要知道它的数学是怎么推出来的  
**记录时间**: 2025-09-25 18:04:47 Thursday

## 第二次算法理解
**记录时间**: 2025-10-01 15:02:27 Wednesday

设设非环段长度为 `a`，环周长为 `c`

慢指针到环口的时候，快指针领先a距离，然后过了b时刻，两指针相遇。
  - 这时候慢指针距离环口的位置为b（为什么不是b%c，因为已经证明第一次相遇的时候慢指针没有走完一圈），
  - 快指针的位置在距离环口(2b+a)%c
  - 相遇的公式为 (2b+a)%c == b, 那么即 (b+a)%c==0, b+a==kc,a==kc-b,故而相遇后再走b步就能到环口。



## 第一次算法理解
**记录时间**: 2025-09-25 18:04:47 Thursday
- **设定**: 慢指针每次走1步，快指针每次走2步

### 关键证明
1. **证明快慢指针必然在慢指针走完一圈前相遇**
   - 设非环段长度为 `a`，环周长为 `c`
   - 当慢指针到达环入口时（走了 `a` 步）：
     - 快指针已走 `2a` 步，位于环中 `(2a % c)` 的位置
     - 两指针距离为 `c - (2a % c)`
   - 由于速度差为1步/单位时间，快指针将在 `k=c - (2a % c)` 时间内追上慢指针
   - `k<c`, 因此慢指针走完一圈前必然被追上

2. **推导环入口位置**
   - 设相遇时：
     - 慢指针走了 `a + k`
     - 快指针走了 `a + nc + k`（n为绕环圈数）
   - 根据速度关系：`2(a + k) = a + nc + k`
   - 解得：`k = nc - a`
   - 这意味着从相遇点再走 `a` 步将到达环入口

3. **确定环入口的方法**
   - 相遇后：
     1. 新指针从头部出发
     2. 慢指针从相遇点出发
     3. 两者以相同速度移动
   - 当新指针走 `a` 步到达入口时：
     - 慢指针共走 `a + k = nc` 步，也到达入口
   - 因此两者必然在环入口相遇

## 逻辑示意图
![示意图](pic/2025-09-25-leetcode142.svg)

## 代码实现
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        
        # 检查是否有环
        has_cycle = False
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                has_cycle = True
                break
                
        if not has_cycle:
            return None
            
        # 寻找环入口
        fast = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
            
        return slow